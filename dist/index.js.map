{"version":3,"file":"index.js","mappings":";;;;;;;;;;;;;AAKc;;AAEd;AACA;AACA;AACA,EAAE,EAAE,sCAAI;;AAER;AACA;AACA;AACA,EAAE,EAAE,2CAAS;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,4CAAU;;AAEd;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,wBAAwB;AACxB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,iEAAiE;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,QAAQ;AACrD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yEAAyE,UAAU;AACnF,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,UAAU,wCAAwC;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AAC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","sources":["webpack://jibs-dom-renderer/./lib/component-node.js","webpack://jibs-dom-renderer/./lib/dom-renderer.js","webpack://jibs-dom-renderer/./lib/fragment-node.js","webpack://jibs-dom-renderer/./lib/native-node.js","webpack://jibs-dom-renderer/./lib/portal-node.js","webpack://jibs-dom-renderer/./lib/text-node.js","webpack://jibs-dom-renderer/../jibs/dist/index.js","webpack://jibs-dom-renderer/webpack/bootstrap","webpack://jibs-dom-renderer/webpack/runtime/define property getters","webpack://jibs-dom-renderer/webpack/runtime/hasOwnProperty shorthand","webpack://jibs-dom-renderer/webpack/runtime/make namespace object","webpack://jibs-dom-renderer/./lib/index.js"],"sourcesContent":["import {\n  Jibs,\n  Components,\n  Renderers,\n  Utils,\n} from 'jibs';\n\nconst {\n  JIB_PROXY,\n  resolveChildren,\n} = Jibs;\n\nconst {\n  CONTEXT_ID,\n  RootNode,\n} = Renderers;\n\nconst {\n  INIT_METHOD,\n  UPDATE_EVENT,\n  PENDING_STATE_UPDATE,\n  LAST_RENDER_TIME,\n  SKIP_STATE_UPDATES,\n} = Components;\n\nconst DEBUG_COMPONENT = 'Router';\n\nexport class ComponentNode extends RootNode {\n  constructor(...args) {\n    super(...args);\n\n    Object.defineProperties(this, {\n      'rootNode': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      'component': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_pendingContextUpdate': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_cachedRenderResult': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_cachedRenderContext': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_cachedWaitingRenderResult': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_previousState': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        {},\n      },\n      '_currentJib': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_lastContextID': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        this.context[CONTEXT_ID] || 1n,\n      },\n    });\n  }\n\n  mergeComponentProps(oldProps, newProps) {\n    let props = Object.assign(Object.create(null), oldProps || {}, newProps);\n    return props;\n  }\n\n  firePropUpdates(_oldProps, _newProps) {\n    let newProps    = _newProps || {};\n    let allPropKeys = new Set(Object.keys(newProps).concat(Object.getOwnPropertySymbols(newProps)));\n\n    let oldProps    = _oldProps || {};\n    let oldPropKeys = Object.keys(oldProps).concat(Object.getOwnPropertySymbols(oldProps));\n    for (let i = 0, il = oldPropKeys.length; i < il; i++)\n      allPropKeys.add(oldPropKeys[i]);\n\n    for (let key of allPropKeys) {\n      let oldValue  = oldProps[key];\n      let newValue  = newProps[key];\n\n      if (oldValue !== newValue)\n        this.component.onPropUpdated(key, newValue, oldValue);\n    }\n  }\n\n  shouldRender(newProps, newChildren) {\n    let component = this.component;\n    if (!component)\n      return true;\n\n    if (this._lastContextID < this.context[CONTEXT_ID]) {\n      this._lastContextID = this.context[CONTEXT_ID];\n      this._previousState = Object.assign({}, component.state);\n\n      this.firePropUpdates(component.props, newProps);\n      component.props = this.mergeComponentProps(component.props, newProps);\n\n      return true;\n    }\n\n    if (this.childrenDiffer(component.children, newChildren)) {\n      this._previousState = Object.assign({}, component.state);\n\n      this.firePropUpdates(component.props, newProps);\n      component.props = this.mergeComponentProps(component.props, newProps);\n\n      return true;\n    }\n\n    let previousState = this._previousState || {};\n    let propsDiffer   = this.propsDiffer(component.props, newProps, [ 'ref', 'key' ], true);\n    if (propsDiffer && component.shouldUpdate(newProps, previousState)) {\n      this._previousState = Object.assign({}, component.state);\n\n      this.firePropUpdates(component.props, newProps);\n      component.props = this.mergeComponentProps(component.props, newProps);\n\n      return true;\n    }\n\n    let stateDiffers = this.propsDiffer(previousState, component.state);\n    if (stateDiffers && component.shouldUpdate(newProps, previousState)) {\n      this._previousState = Object.assign({}, component.state);\n      return true;\n    }\n\n    return false;\n  }\n\n  async destroy() {\n    if (this.destroying)\n      return;\n\n    this.destroying = true;\n\n    await this.renderPromise;\n\n    if (this.component) {\n      if (this._currentJib && typeof this._currentJib.props.ref === 'function')\n        this._currentJib.props.ref.call(this.component, null, this.component);\n\n      await this.component.destroy();\n      this.component = null;\n    }\n\n    if (this.rootNode) {\n      await this.rootNode.destroy();\n      this.rootNode = null;\n    }\n\n    this._cachedRenderResult = null;\n    this._previousState = null;\n    this._currentJib = null;\n\n    return await super.destroy();\n  }\n\n  onContextUpdate() {\n    if (!this.component || this.component[SKIP_STATE_UPDATES] || this.component[PENDING_STATE_UPDATE]) {\n      if (this.component && this.component.constructor.name === DEBUG_COMPONENT)\n        console.log('Skipping context update!');\n\n      return Promise.resolve();\n    }\n\n    return Promise.resolve().then(async () => {\n      if (this.component && this.component.constructor.name === DEBUG_COMPONENT)\n        console.log('Updating due to context change!', this._currentJib);\n\n      await this.render(this._currentJib, this._cachedRenderContext || { index: 0 });\n    });\n  }\n\n  resolveChildren(children) {\n    return resolveChildren.call(this, children);\n  }\n\n  async syncElementsWithRenderer(node, renderResult, renderFrame) {\n    if (!this.parent)\n      return;\n\n    if (renderResult === undefined)\n      debugger;\n\n    if (this.component && this.component.constructor.name === DEBUG_COMPONENT)\n      console.log('Syncing DOM!', renderResult);\n\n    let result = await this.parent.syncElementsWithRenderer(node, renderResult, renderFrame);\n\n    if (this.component)\n      this.component.updated();\n\n    return result;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  async _render(jib, renderContext) {\n    if (jib !== this._currentJib)\n      this._currentJib = jib;\n\n    this._cachedRenderContext = renderContext;\n\n    if (!jib)\n      return;\n\n    let renderFrame = this.renderFrame;\n\n    let { Type: ComponentClass, props, children } = jib;\n    jib.children = await this.resolveChildren(children);\n\n    const finalizeRender = async (renderResult, renderFrame) => {\n      if (this.destroying || renderFrame < this.renderFrame || !this.component) {\n        if (ComponentClass && ComponentClass.name === DEBUG_COMPONENT)\n          console.log('Aborting!!!');\n\n        return;\n      }\n\n      this.component[LAST_RENDER_TIME] = Utils.now();\n\n      let rootNode = this.rootNode;\n      if (!rootNode)\n        rootNode = this.rootNode = this.renderer.constructNodeFromJib(JIB_PROXY, this, this.context);\n\n      if (ComponentClass && ComponentClass.name === DEBUG_COMPONENT)\n        console.log('Render result!!!', renderResult);\n\n      let fragmentResult = this._cachedRenderResult = await rootNode.render(renderResult, renderContext);\n      await this.syncElementsWithRenderer(this, fragmentResult, renderFrame);\n\n      return fragmentResult;\n    };\n\n    const handleRenderError = (error) => {\n      if (this.destroying || renderFrame < this.renderFrame)\n        return;\n\n      console.error(error);\n\n      if (this.component)\n        this.component[LAST_RENDER_TIME] = Utils.now();\n\n      let renderResult;\n\n      try {\n        if (this.component && typeof this.component.renderErrorState === 'function')\n          renderResult = this.component.renderErrorState(error);\n        else\n          renderResult = [ `${error.message}\\n${error.stack}` ];\n      } catch (error2) {\n        renderResult = [ `${error.message}\\n${error.stack}` ];\n      }\n\n      return finalizeRender(renderResult, renderFrame);\n    };\n\n    try {\n      if (this.component && !this.shouldRender(jib.props, jib.children)) {\n        if (ComponentClass && ComponentClass.name === DEBUG_COMPONENT)\n          console.log('Returning cached result!', this._cachedRenderResult);\n\n        return this._cachedRenderResult;\n      } else {\n        let component = this.component;\n        if (!component) {\n          if (this.destroying || renderFrame < this.renderFrame)\n            return;\n\n          component = this.component = new ComponentClass({ ...jib, props: this.mergeComponentProps(null, props), context: this.context, id: this.id });\n          if (typeof component[INIT_METHOD] === 'function')\n            component[INIT_METHOD]();\n\n          component.on(UPDATE_EVENT, async (pushedRenderResult) => {\n            if (pushedRenderResult) {\n              this.renderFrame++;\n              await finalizeRender(pushedRenderResult, this.renderFrame);\n            } else {\n              await this.render(this._currentJib, this._cachedRenderContext || { index: 0 });\n            }\n          });\n\n          if (props && typeof props.ref === 'function')\n            props.ref.call(component, component, null);\n        }\n\n        // Cancel any pending state updates\n        if (this.component[PENDING_STATE_UPDATE])\n          this.component[PENDING_STATE_UPDATE] = null;\n\n        let renderResult = this.component.render(jib.children);\n        if (Utils.instanceOf(renderResult, 'promise')) {\n          let waitingRenderResult = this.component.renderWaiting(this._cachedRenderResult);\n          let renderCompleted = false;\n\n          let loadingTimer = setTimeout(async () => {\n            loadingTimer = null;\n\n            if (Utils.instanceOf(waitingRenderResult, 'promise'))\n              waitingRenderResult = await waitingRenderResult;\n\n            if (renderCompleted)\n              return;\n\n            await finalizeRender(waitingRenderResult, renderFrame);\n          }, 5);\n\n          return await renderResult.then(async (renderResult) => {\n            renderCompleted = true;\n\n            if (loadingTimer) {\n              clearTimeout(loadingTimer);\n              loadingTimer = null;\n            }\n\n            return await finalizeRender(renderResult, renderFrame);\n          }).catch(handleRenderError);\n        } else {\n          return await finalizeRender(renderResult, renderFrame);\n        }\n      }\n    } catch (error) {\n      return await handleRenderError(error);\n    }\n  }\n}\n","import {\n  Jibs,\n  Renderers,\n  Utils,\n} from 'jibs';\n\nimport { FragmentNode }  from './fragment-node.js';\nimport { TextNode }      from './text-node.js';\nimport { NativeNode }    from './native-node.js';\nimport { PortalNode }    from './portal-node.js';\nimport { ComponentNode } from './component-node.js';\n\nconst { Renderer } = Renderers;\n\nconst {\n  JIB_PROXY,\n} = Jibs;\n\nexport class DOMRenderer extends Renderer {\n  static FragmentNode = FragmentNode;\n\n  static TextNode = TextNode;\n\n  static NativeNode = NativeNode;\n\n  static PortalNode = PortalNode;\n\n  static ComponentNode = ComponentNode;\n\n  constructor(rootElement) {\n    super();\n\n    Object.defineProperties(this, {\n      'rootElement': {\n        writable:     false,\n        enumerable:   false,\n        configurable: false,\n        value:        rootElement,\n      },\n      'rootNode': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n    });\n  }\n\n  isPortalNode(type) {\n    return (/[^a-zA-Z0-9:]/).test(type);\n  }\n\n  constructNodeFromJib(jib, parent, context) {\n    if (jib === JIB_PROXY)\n      return new this.constructor.FragmentNode(this, parent, context);\n\n    let { Type } = jib;\n    if (typeof Type === 'function') {\n      return new this.constructor.ComponentNode(this, parent, context);\n    } else if (typeof Type === 'string') {\n      if (this.isPortalNode(Type))\n        return new this.constructor.PortalNode(this, parent, context);\n      else\n        return new this.constructor.NativeNode(this, parent, context);\n    } else if (Type == null || Type === JIB_PROXY) {\n      return new this.constructor.FragmentNode(this, parent, context);\n    }\n  }\n\n  async syncElementsWithRenderer(node, renderResult, renderFrame) {\n    if (this.destroying)\n      return;\n\n    await this.updateElementChildren(\n      this.context,\n      this.rootElement,\n      renderResult,\n      renderFrame,\n    );\n  }\n\n  async render(jib) {\n    this.renderFrame++;\n    let renderFrame = this.renderFrame;\n\n    let rootNode = this.rootNode;\n    if (!rootNode)\n      rootNode = this.rootNode = this.constructNodeFromJib(JIB_PROXY, this, this.context);\n\n    let renderResult = await rootNode.render(jib, { index: 0 });\n    await this.syncElementsWithRenderer(\n      this,\n      renderResult,\n      renderFrame,\n    );\n\n    return renderResult;\n  }\n}\n","import {\n  Jibs,\n  Renderers,\n  Utils,\n  deadbeef,\n} from 'jibs';\n\nconst {\n  isJibish,\n  constructJib,\n  JIB_PROXY,\n} = Jibs;\n\nconst {\n  RootNode,\n} = Renderers;\n\nconst TEXT_TYPE     = Symbol.for('@jib/textNode');\nconst FRAGMENT_TYPE = Symbol.for('@jib/fragmentNode');\n\nexport class FragmentNode extends RootNode {\n  constructor(...args) {\n    super(...args);\n\n    Object.defineProperties(this, {\n      '_nodeCache': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        new Map(),\n      },\n    });\n  }\n\n  async destroy() {\n    if (this.destroying)\n      return;\n\n    this.destroying = true;\n\n    if (this._nodeCache) {\n      let destroyPromises = [];\n      let nodeCache       = this._nodeCache;\n\n      this._nodeCache = null;\n\n      for (let cachedResult of nodeCache.values()) {\n        if (cachedResult && cachedResult.node && cachedResult.node.destroy)\n          destroyPromises.push(cachedResult.node.destroy());\n      }\n\n      nodeCache.clear();\n\n      await Promise.all(destroyPromises);\n    }\n\n    return await super.destroy();\n  }\n\n  async syncElementsWithRenderer(node, renderResult, renderFrame) {\n    if (!this.parent || this.renderPromise) {\n      console.log('Aborting fragment!');\n      return;\n    }\n\n    if (!this._nodeCache)\n      return await this.parent.syncElementsWithRenderer(node, renderResult, renderFrame);\n\n    let renderResults = [];\n    for (let [ cacheKey, cachedResult ] of this._nodeCache) {\n      if (cachedResult.node === node) {\n        this._nodeCache.set(cacheKey, { ...cachedResult, renderResult });\n        renderResults.push(renderResult);\n      } else {\n        renderResults.push(cachedResult.renderResult);\n      }\n    }\n\n    return await this.parent.syncElementsWithRenderer(node, renderResults, renderFrame);\n  }\n\n  async _render(_children, renderContext) {\n    let indexMap    = new Map();\n    let children    = _children;\n    let renderFrame = this.renderFrame;\n\n    if (Utils.instanceOf(children, 'promise'))\n      children = await children;\n\n    if (this.destroying || renderFrame < this.renderFrame)\n      return;\n\n    if (!this.isIterableChild(children) && (isJibish(children) || this.isValidChild(children)))\n      children = [ children ];\n\n    const getIndexForType = (Type) => {\n      let index = (indexMap.get(Type) || 0) + 1;\n      indexMap.set(Type, index);\n\n      return index;\n    };\n\n    let loopStopped = false;\n    let promises = Utils.iterate(children, ({ value: _child, key, index, STOP }) => {\n      if (loopStopped || this.destroying || renderFrame < this.renderFrame)\n        return STOP;\n\n      return (async () => {\n        let child = (Utils.instanceOf(_child, 'promise')) ? await _child : _child;\n        let created;\n        let cacheKey;\n        let node;\n        let renderResult;\n\n        if (isJibish(child)) {\n          let jib = constructJib(child);\n          if (Utils.instanceOf(jib, 'promise'))\n            jib = await jib;\n\n          if (this.destroying || renderFrame < this.renderFrame) {\n            loopStopped = true;\n            return;\n          }\n\n          let { Type, props } = jib;\n          if (!props)\n            props = {};\n\n          let localKey;\n          if (index !== key) // Index is an integer, and key is a string, meaning this is an object\n            localKey = key;\n          else\n            localKey = (props.key == null || Object.is(props.key, NaN) || Object.is(props.key, Infinity)) ? `@jib/internal_key_${getIndexForType(Type)}` : props.key;\n\n          cacheKey = deadbeef(Type, localKey);\n\n          let cachedResult = this._nodeCache.get(cacheKey);\n          if (!cachedResult) {\n            created = true;\n            node = this.renderer.constructNodeFromJib(jib, this, this.context);\n          } else {\n            created = false;\n            node = cachedResult.node;\n          }\n\n          if (Type === JIB_PROXY)\n            renderResult = await node.render(jib.children, renderContext);\n          else\n            renderResult = await node.render(jib, renderContext);\n        } else if (this.isIterableChild(child)) {\n          if (Utils.isEmpty(child))\n            return;\n\n          cacheKey = deadbeef(`@jib/internal_fragment_${getIndexForType(FRAGMENT_TYPE)}`);\n\n          let cachedResult = this._nodeCache.get(cacheKey);\n          if (!cachedResult) {\n            created = true;\n            node = this.renderer.constructNodeFromJib(JIB_PROXY, this, this.context);\n          } else {\n            created = false;\n            node = cachedResult.node;\n          }\n\n          renderResult = await node.render(child, renderContext);\n        } else if (this.isValidChild(child)) {\n          child = (typeof child.valueOf === 'function') ? child.valueOf() : child;\n          cacheKey = deadbeef(`@jib/internal_text_${getIndexForType(TEXT_TYPE)}`);\n\n          let cachedResult = this._nodeCache.get(cacheKey);\n          if (!cachedResult) {\n            created = true;\n            node = new this.renderer.constructor.TextNode(this.renderer, this, this.context);\n          } else {\n            created = false;\n            node = cachedResult.node;\n          }\n\n          renderResult = await node.render(child, renderContext);\n        }\n\n        return { node, cacheKey, renderResult, created };\n      })();\n    });\n\n    let renderResults = await Promise.all(promises);\n    renderResults = renderResults.filter((result) => !!result);\n\n    let destroyPromises = [];\n    if (this.destroying || renderFrame < this.renderFrame) {\n      for (let i = 0, il = renderResults.length; i < il; i++) {\n        let result = renderResults[i];\n        let { node, created } = result;\n\n        if (created && node) {\n          // Destroy nodes since this render was rejected.\n          // But only nodes that were just created...\n          // as existing nodes might still need to exist.\n          destroyPromises.push(node.destroy());\n        }\n      }\n\n      if (destroyPromises.length > 0)\n        await Promise.all(destroyPromises);\n\n      return;\n    }\n\n    let nodeMap = new Map();\n    for (let i = 0, il = renderResults.length; i < il; i++) {\n      let renderResult = renderResults[i];\n      nodeMap.set(renderResult.cacheKey, renderResult);\n    }\n\n    if (this._nodeCache) {\n      // Cleanup\n      for (let [ cacheKey, renderResult ] of this._nodeCache) {\n        let hasChild = nodeMap.has(cacheKey);\n        if (!hasChild) {\n          // This node was destroyed\n          destroyPromises.push(renderResult.node.destroy());\n        }\n      }\n\n      this._nodeCache = nodeMap;\n\n      if (destroyPromises.length > 0)\n        await Promise.all(destroyPromises);\n    } else {\n      this._nodeCache = nodeMap;\n    }\n\n    return renderResults.map((renderResult) => renderResult.renderResult).filter((result) => (result != null && !Object.is(result, NaN) && !Object.is(result, Infinity)));\n  }\n}\n","import {\n  Jibs,\n  Renderers,\n  Utils,\n} from 'jibs';\n\nconst {\n  JIB_PROXY,\n} = Jibs;\n\nconst {\n  RootNode,\n  NativeElement,\n  TextElement,\n} = Renderers;\n\nexport class NativeNode extends RootNode {\n  static ELEMENT_CLASS = NativeElement;\n\n  constructor(...args) {\n    super(...args);\n\n    Object.defineProperties(this, {\n      'rootNode': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_currentJib': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        null,\n      },\n      '_cachedRenderResult': {\n        writable:     true,\n        enumerable:   false,\n        configurable: true,\n        value:        { id: this.id },\n      },\n    });\n  }\n\n  async syncElementsWithRenderer(node, renderResult, renderFrame) {\n    if (!this.renderer || this.destroying)\n      return;\n\n    await this.renderer.updateElementChildren(\n      this.context,\n      this._cachedRenderResult,\n      renderResult,\n      renderFrame,\n    );\n  }\n\n  async destroy() {\n    if (this.destroying)\n      return;\n\n    this.destroying = true;\n\n    if (this.rootNode) {\n      await this.rootNode.destroy();\n      this.rootNode = null;\n    }\n\n    return await super.destroy();\n  }\n\n  async _render(jib, renderContext) {\n    let {\n      Type,\n      props,\n      children,\n    } = this._currentJib = (jib || {});\n\n    if (!Type)\n      return;\n\n    let renderFrame = this.renderFrame;\n\n    if (!Object.prototype.hasOwnProperty.call(props, 'innerHTML')) {\n      let rootNode = this.rootNode;\n      if (!rootNode)\n        rootNode = this.rootNode = this.renderer.constructNodeFromJib(JIB_PROXY, this, this.context);\n\n      let newContext = Object.create(renderContext);\n      newContext.index = 0;\n\n      rootNode.render(children, newContext).then((fragmentResult) => {\n        return this.syncElementsWithRenderer(this, fragmentResult, renderFrame);\n      }).catch((_error) => {\n        let error = _error;\n        if (!(error instanceof Error))\n          error = new Error(error);\n\n        return this.syncElementsWithRenderer(this, [ new TextElement(null, error, props) ], renderFrame);\n      });\n    } else {\n      if (this.rootNode) {\n        await this.rootNode.destroy();\n        this.rootNode = null;\n      }\n    }\n\n    let renderResult = this._cachedRenderResult = new this.constructor.ELEMENT_CLASS(\n      this.id,\n      Type,\n      props,\n    );\n\n    return renderResult;\n  }\n}\n","import {\n  Renderers,\n} from 'jibs';\n\nimport { NativeNode } from './native-node.js';\n\nconst {\n  PortalElement,\n} = Renderers;\n\nexport class PortalNode extends NativeNode {\n  static ELEMENT_CLASS = PortalElement;\n}\n","import {\n  Renderers,\n} from 'jibs';\n\nconst {\n  RootNode,\n  TextElement,\n} = Renderers;\n\nexport class TextNode extends RootNode {\n  async destroy() {\n    if (this.destroying)\n      return;\n\n    this.destroying = true;\n\n    return await super.destroy();\n  }\n\n  async _render(text) {\n    return new TextElement(this.id, text);\n  }\n}\n","var e={711:function(e,t,r){const n=(\"undefined\"!=typeof window?window:r.g)||this,i=Symbol.for(\"@@deadbeefRefMap\"),o=Symbol.for(\"@@deadbeefUniqueID\"),l=n[i]?n[i]:new WeakMap,s=[];n[i]||(n[i]=l);let a=0n;function anythingToID(e,t){let r=e;(r instanceof Number||r instanceof String||r instanceof Boolean)&&(r=r.valueOf());let n=typeof r;if(\"number\"===n&&0===r)return Object.is(r,-0)?\"number:-0\":\"number:+0\";if(\"symbol\"===n)return`symbol:${r.toString()}`;if(null==r||\"number\"===n||\"boolean\"===n||\"string\"===n||\"bigint\"===n)return\"number\"===n?r<0?`number:${r}`:`number:+${r}`:\"bigint\"===n&&0n===r?\"bigint:+0\":`${n}:${r}`;let i=s.length>0&&function getHelperForValue(e){for(let t=0,r=s.length;t<r;t++){let{helper:r,generator:n}=s[t];if(r(e))return n}}(r);if(i)return anythingToID(i(r));if(o in r&&\"function\"==typeof r[o]&&(!t||!t.has(r))){let e=t||new Set;return e.add(r),anythingToID(r[o](),e)}if(!l.has(r)){let e=`${typeof r}:${++a}`;return l.set(r,e),e}return l.get(r)}function deadbeef(){let e=[arguments.length];for(let t=0,r=arguments.length;t<r;t++)e.push(anythingToID(arguments[t]));return e.join(\":\")}Object.defineProperties(deadbeef,{idSym:{writable:!0,enumerable:!1,configurable:!0,value:o},sorted:{writable:!0,enumerable:!1,configurable:!0,value:function deadbeefSorted(){let e=[arguments.length];for(let t=0,r=arguments.length;t<r;t++)e.push(anythingToID(arguments[t]));return e.sort().join(\":\")}},generateIDFor:{writable:!0,enumerable:!1,configurable:!0,value:function generateIDFor(e,t){s.push({helper:e,generator:t})}},removeIDGenerator:{writable:!0,enumerable:!1,configurable:!0,value:function removeIDGenerator(e){let t=s.findIndex((t=>t.helper===e));t<0||s.splice(t,1)}}}),e.exports=deadbeef}},t={};function __webpack_require__(r){var n=t[r];if(void 0!==n)return n.exports;var i=t[r]={exports:{}};return e[r].call(i.exports,i,i.exports,__webpack_require__),i.exports}__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(e){if(\"object\"==typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})};var r={};(()=>{__webpack_require__.d(r,{$:()=>c,wA:()=>Component,z8:()=>P,El:()=>T,pv:()=>S,cQ:()=>e,Be:()=>t,d5:()=>factory});var e={};__webpack_require__.r(e),__webpack_require__.d(e,{bindMethods:()=>bindMethods,childrenDiffer:()=>childrenDiffer,fetchDeepProperty:()=>fetchDeepProperty,flattenArray:()=>flattenArray,instanceOf:()=>instanceOf,isEmpty:()=>isEmpty,isIterableChild:()=>isIterableChild,isNotEmpty:()=>isNotEmpty,isValidChild:()=>isValidChild,iterate:()=>o,now:()=>now,propsDiffer:()=>propsDiffer,sizeOf:()=>sizeOf});var t=__webpack_require__(711);const n=Symbol.for(\"@jibsIterateStop\"),i=\"undefined\"!=typeof global?global:\"undefined\"!=typeof window?window:void 0;function instanceOf(e){function testType(e,t){let r=t,n=typeof e;return r===i.String?r=\"string\":r===i.Number?r=\"number\":r===i.Boolean?r=\"boolean\":r===i.Function?r=\"function\":r===i.Array?r=\"array\":r===i.Object?r=\"object\":r===i.Promise?r=\"promise\":r===i.BigInt?r=\"bigint\":r===i.Map?r=\"map\":r===i.WeakMap?r=\"weakmap\":r===i.Set?r=\"set\":r===i.Symbol?r=\"symbol\":r===i.Buffer&&(r=\"buffer\"),!(\"buffer\"!==r||!i.Buffer||!i.Buffer.isBuffer(e))||(\"number\"===r&&(\"number\"===n||e instanceof Number||e.constructor&&\"Number\"===e.constructor.name)?!!isFinite(e):\"object\"!==r&&r===n||(\"object\"===r?!!(e.constructor===Object.prototype.constructor||e.constructor&&\"Object\"===e.constructor.name)||\"object\"===n&&!e.constructor:!(\"array\"!==r||!(Array.isArray(e)||e instanceof Array||e.constructor&&\"Array\"===e.constructor.name))||(!(\"promise\"!==r&&\"deferred\"!==r||!function isDeferredType(e){return!!(e instanceof Promise||e.constructor&&\"Promise\"===e.constructor.name)||\"function\"==typeof e.then&&\"function\"==typeof e.catch}(e))||(!(\"string\"!==r||!(e instanceof i.String||e.constructor&&\"String\"===e.constructor.name))||(!(\"boolean\"!==r||!(e instanceof i.Boolean||e.constructor&&\"Boolean\"===e.constructor.name))||(!(\"map\"!==r||!(e instanceof i.Map||e.constructor&&\"Map\"===e.constructor.name))||(!(\"weakmap\"!==r||!(e instanceof i.WeakMap||e.constructor&&\"WeakMap\"===e.constructor.name))||(!(\"set\"!==r||!(e instanceof i.Set||e.constructor&&\"Set\"===e.constructor.name))||(\"function\"===r&&\"function\"===n||(\"function\"==typeof r&&e instanceof r||!(\"string\"!=typeof r||!e.constructor||e.constructor.name!==r)))))))))))}if(null==e)return!1;for(var t=1,r=arguments.length;t<r;t++)if(!0===testType(e,arguments[t]))return!0;return!1}function propsDiffer(e,t,r){if(e===t)return!1;if(typeof e!=typeof t)return!0;if(!e&&t)return!0;if(e&&!t)return!0;if(!e&&!t&&e!=e)return!0;let n=Object.keys(e).concat(Object.getOwnPropertySymbols(e)),i=Object.keys(t).concat(Object.getOwnPropertySymbols(t));if(n.length!==i.length)return!0;for(let o=0,l=n.length;o<l;o++){let l=n[o];if(r&&r.indexOf(l)>=0)continue;if(e[l]!==t[l])return!0;let s=i[o];if((!r||!r.indexOf(s))&&(l!==s&&e[s]!==t[s]))return!0}return!1}function sizeOf(e){return e?Object.is(1/0)?0:\"number\"==typeof e.length?e.length:Object.keys(e).length:0}function _iterate(e,t){if(!e||Object.is(1/0))return[];let r,i=[],o={collection:e,STOP:n};if(Array.isArray(e)){o.type=\"Array\";for(let l=0,s=e.length;l<s&&(o.value=e[l],o.index=o.key=l,r=t.call(this,o),r!==n);l++)i.push(r)}else if(\"function\"==typeof e.entries)if(e instanceof Set||\"Set\"===e.constructor.name){o.type=\"Set\";let l=0;for(let s of e.values()){if(o.value=s,o.key=s,o.index=l++,r=t.call(this,o),r===n)break;i.push(r)}}else{o.type=e.constructor.name;let l=0;for(let[s,a]of e.entries()){if(o.value=a,o.key=s,o.index=l++,r=t.call(this,o),r===n)break;i.push(r)}}else{if(instanceOf(e,\"boolean\",\"number\",\"bigint\",\"function\"))return;o.type=e.constructor?e.constructor.name:\"Object\";let l=Object.keys(e);for(let s=0,a=l.length;s<a;s++){let a=l[s],c=e[a];if(o.value=c,o.key=a,o.index=s,r=t.call(this,o),r===n)break;i.push(r)}}return i}Object.defineProperties(_iterate,{STOP:{writable:!1,enumerable:!1,configurable:!1,value:n}});const o=_iterate;function childrenDiffer(e,r){let n=Array.isArray(e)?e:[e],i=Array.isArray(r)?r:[r];return t(...n)!==t(...i)}function fetchDeepProperty(e,t,r,n){if(null==e||Object.is(NaN,e)||Object.is(1/0,e))return n?[r,null]:r;if(null==t||Object.is(NaN,t)||Object.is(1/0,t))return n?[r,null]:r;let i;if(Array.isArray(t))i=t;else if(\"symbol\"==typeof t)i=[t];else{let e=\"\"+t,r=0,n=0;for(i=[];;){let t=e.indexOf(\".\",r);if(t<0){i.push(e.substring(n));break}\"\\\\\"!==e.charAt(t-1)?(i.push(e.substring(n,t)),n=r=t+1):r=t+1}}let o=i[i.length-1];if(0===i.length)return n?[r,o]:r;let l=e;for(let e=0,t=i.length;e<t;e++){if(l=l[i[e]],null==l)return n?[r,o]:r}return n?[l,o]:l}function bindMethods(e,t){let r=e,n=new Set;for(;r;){let e=Object.getOwnPropertyDescriptors(r),i=Object.keys(e).concat(Object.getOwnPropertySymbols(e));for(let e=0,t=i.length;e<t;e++){let t=i[e];if(\"constructor\"===t)continue;if(n.has(t))continue;n.add(t);let o=r[t];Object.prototype.hasOwnProperty(t)&&Object.prototype[t]===o||\"function\"==typeof o&&(this[t]=o.bind(this))}if(r=Object.getPrototypeOf(r),r===Object.prototype)break;if(t&&t.indexOf(r)>=0)break}}function isEmpty(e){return null==e||!Object.is(e,1/0)&&(!!Object.is(e,NaN)||(instanceOf(e,\"string\")?!/\\S/.test(e):(!instanceOf(e,\"number\")||!isFinite(e))&&(!instanceOf(e,\"boolean\",\"bigint\",\"function\")&&0===sizeOf(e))))}function isNotEmpty(e){return!isEmpty.call(this,e)}function flattenArray(e){if(!Array.isArray(e))return e;let t=[];for(let r=0,n=e.length;r<n;r++){let n=e[r];Array.isArray(n)?t=t.concat(flattenArray(n)):t.push(n)}return t}function isValidChild(e){return null!=e&&(\"boolean\"!=typeof e&&(!Object.is(e,1/0)&&!Object.is(e,NaN)))}function isIterableChild(e){return null!=e&&!Object.is(e,NaN)&&!Object.is(e,1/0)&&(Array.isArray(e)||\"object\"==typeof e&&!instanceOf(e,\"boolean\",\"number\",\"string\"))}function now(){return\"undefined\"!=typeof performance&&\"function\"==typeof performance.now?performance.now():Date.now()}class Jib{constructor(e,t,r){let n=e&&e.props?e.props:{};Object.defineProperties(this,{Type:{writable:!0,enumerable:!0,configurable:!0,value:e},props:{writable:!0,enumerable:!0,configurable:!0,value:{...n,...t||{}}},children:{writable:!0,enumerable:!0,configurable:!0,value:flattenArray(r)}})}}const l=Symbol.for(\"@jibs.barren\"),s=Symbol.for(\"@jibs.proxy\"),a=Symbol.for(\"@jibs.jib\");function factory(e){return function $(r,n={}){if(isJibish(r))throw new TypeError(\"Received a jib but expected a component.\");let i=null==r?s:r;function barren(...r){let o=r;function jib(){return instanceOf(i,\"promise\")||o.some((e=>instanceOf(e,\"promise\")))?Promise.all([i].concat(o)).then((t=>(i=t[0],o=t.slice(1),new e(i,n,o)))):new e(i,n,o)}return Object.defineProperties(jib,{[a]:{writable:!1,enumerable:!1,configurable:!1,value:!0},[t.idSym]:{writable:!1,enumerable:!1,configurable:!1,value:()=>i}}),jib}return Object.defineProperties(barren,{[l]:{writable:!1,enumerable:!1,configurable:!1,value:!0},[t.idSym]:{writable:!1,enumerable:!1,configurable:!1,value:()=>i}}),barren}}const c=factory(Jib);function isJibish(e){return!(\"function\"!=typeof e||!e[l]&&!e[a])||e instanceof Jib}function constructJib(e){if(e instanceof Jib)return e;if(\"function\"==typeof e){if(e[l])return e()();if(e[a])return e()}throw new TypeError(\"constructJib: Provided value is not a Jib.\")}async function resolveChildren(e){let t=e;instanceOf(t,\"promise\")&&(t=await t),(this.isIterableChild||isIterableChild).call(this,t)||!isJibish(t)&&!(this.isValidChild||isValidChild).call(this,t)||(t=[t]);let r=o(t,(async({value:e})=>{let t=instanceOf(e,\"promise\")?await e:e;return isJibish(t)?await constructJib(t):t}));return await Promise.all(r)}const u=Symbol.for(\"@jibs/events/listeners\");class EventEmitter{constructor(){Object.defineProperties(this,{[u]:{writable:!1,enumerable:!1,configurable:!1,value:new Map}})}addListener(e,t){if(\"function\"!=typeof t)throw new TypeError(\"Event listener must be a method\");let r=this[u],n=r.get(e);return n||(n=[],r.set(e,n)),n.push(t),this}removeListener(e,t){if(\"function\"!=typeof t)throw new TypeError(\"Event listener must be a method\");let r=this[u].get(e);if(!r)return this;let n=r.indexOf(t);return n>=0&&r.splice(n,1),this}removeAllListeners(e){let t=this[u];return t.has(e)?(t.set(e,[]),this):this}emit(e,...t){let r=this[u].get(e);if(!r||0===r.length)return!1;for(let e=0,n=r.length;e<n;e++){r[e].apply(this,t)}return!0}once(e,t){let func=(...r)=>(this.off(e,func),t(...r));return this.on(e,func)}on(e,t){return this.addListener(e,t)}off(e,t){return this.removeListener(e,t)}eventNames(){return Array.from(this[u].keys())}listenerCount(e){let t=this[u].get(e);return t?t.length:0}listeners(e){let t=this[u].get(e);return t?t.slice():[]}}const f=\"@jibs/component/event/update\",b=Symbol.for(\"@jibs/component/queueUpdate\"),p=Symbol.for(\"@jibs/component/flushUpdate\"),d=Symbol.for(\"@jibs/component/__init\"),h=Symbol.for(\"@jibs/component/skipStateUpdates\"),m=Symbol.for(\"@jibs/component/pendingStateUpdate\"),y=Symbol.for(\"@jibs/component/lastRenderTime\"),g=Symbol.for(\"@jibs/component/previousState\"),O=Symbol.for(\"@jibs/component/previousState\"),E=new WeakMap;function isValidStateObject(e){if(null==e)return!1;if(Object.is(e,NaN))return!1;if(Object.is(e,1/0))return!1;if(e instanceof Boolean||e instanceof Number||e instanceof String)return!1;let t=typeof e;return\"string\"!==t&&\"number\"!==t&&\"boolean\"!==t&&(!Array.isArray(e)&&(\"undefined\"==typeof Buffer||!Buffer.isBuffer(e)))}class Component extends EventEmitter{static UPDATE_EVENT=f;[b](){this[m]||(this[m]=Promise.resolve(),this[m].then(this[p].bind(this)))}[p](){this[m]&&(this.emit(f),this[m]=null)}[d](){this[h]=!1}constructor(e){super(),bindMethods.call(this,this.constructor.prototype);let t=e||{};let r=Object.assign(Object.create(null),t.props||{}),n=(()=>{let e=Object.create(null);return new Proxy(e,{get:(e,t)=>e[t],set:(e,t,r)=>{let n=e[t];return n===r||(this[h]||this[b](),e[t]=r,this.onStateUpdated(t,r,n)),!0}})})();Object.defineProperties(this,{[h]:{writable:!0,enumerable:!1,configurable:!0,value:!0},[m]:{writable:!0,enumerable:!1,configurable:!0,value:null},[y]:{writable:!0,enumerable:!1,configurable:!0,value:now()},[O]:{writable:!0,enumerable:!1,configurable:!0,value:{}},id:{writable:!1,enumerable:!1,configurable:!1,value:t.id},props:{writable:!0,enumerable:!1,configurable:!0,value:r},children:{writable:!0,enumerable:!1,configurable:!0,value:t.children||[]},context:{writable:!0,enumerable:!1,configurable:!0,value:t.context||Object.create(null)},state:{enumerable:!1,configurable:!0,get:()=>n,set:e=>{if(!isValidStateObject(e))throw new TypeError(`Invalid value for \"this.state\": \"${e}\". Provided \"state\" must be an iterable object.`);Object.assign(n,e)}}})}resolveChildren(e){return resolveChildren.call(this,e)}isJib(e){return isJibish(e)}constructJib(e){return constructJib(e)}pushRender(e){this.emit(f,e)}onPropUpdated(e,t,r){}onStateUpdated(e,t,r){}captureReference(e,t){let r=this[O][e];return r||(r=(r,n)=>{let i=r;\"function\"==typeof t&&(i=t.call(this,i,n)),Object.defineProperties(this,{[e]:{writable:!0,enumerable:!1,configurable:!0,value:i}})},\"function\"!=typeof t&&(this[O]=r),r)}forceUpdate(){this[b]()}getState(e,t){let r=this.state;if(0===arguments.length)return r;if(instanceOf(e,\"object\")){let t=Object.keys(e).concat(Object.getOwnPropertySymbols(e)),n={};for(let i=0,o=t.length;i<o;i++){let o=t[i],[l,s]=fetchDeepProperty(r,o,e[o],!0);null!=s&&(n[s]=l)}return n}return fetchDeepProperty(r,e,t)}setState(e){if(!isValidStateObject(e))throw new TypeError(`Invalid value for \"this.setState\": \"${e}\". Provided \"state\" must be an iterable object.`);Object.assign(this.state,e)}setStatePassive(e){if(!isValidStateObject(e))throw new TypeError(`Invalid value for \"this.setStatePassive\": \"${e}\". Provided \"state\" must be an iterable object.`);try{this[h]=!0,Object.assign(this.state,e)}finally{this[h]=!1}}shouldUpdate(){return!0}destroy(){delete this.state,delete this.props,delete this.context,delete this[O],this.clearAllDebounces()}renderWaiting(){}render(e){return e}updated(){}combineWith(e,...t){let r=new Set;for(let n=0,i=t.length;n<i;n++){let i=t[n];if(i)if(instanceOf(i,\"string\")){let t=i.split(e).filter(isNotEmpty);for(let e=0,n=t.length;e<n;e++){let n=t[e];r.add(n)}}else if(Array.isArray(i)){let e=i.filter((e=>!!e&&(!!instanceOf(e,\"string\")&&isNotEmpty(e))));for(let t=0,n=e.length;t<n;t++){let n=e[t];r.add(n)}}else if(instanceOf(i,\"object\")){let e=Object.keys(i);for(let t=0,n=e.length;t<n;t++){let n=e[t];i[n]?r.add(n):r.delete(n)}}}return Array.from(r).join(e||\"\")}classes(...e){return this.combineWith(\" \",...e)}extractChildren(e,t){let r={},n=e,i=Array.isArray(n);return r.remainingChildren=t.filter((e=>!(e=>{let t=e.Type;if(instanceOf(t,\"string\")&&(t=t.toLowerCase()),i)for(let i=0,o=n.length;i<o;i++){let o=n[i];if(instanceOf(o,\"string\")&&(o=o.toLowerCase()),t===o)return r[o]=e,!0}else{let i=Object.keys(n);for(let o=0,l=i.length;o<l;o++){let l,s=i[o],a=n[s];if(l=instanceOf(a,RegExp)?a.test(t):instanceOf(a,\"string\")?a.toLowerCase()===t:a===t,l)return r[s]=e,!0}}return!1})(e))),r}debounce(e,t,r){const clearPendingTimeout=()=>{i&&i.timeout&&(clearTimeout(i.timeout),i.timeout=null)};var n=r||\"\"+e;this.debounceTimers||Object.defineProperty(this,\"debounceTimers\",{writable:!0,enumerable:!1,configurable:!0,value:{}});var i=this.debounceTimers[n];i||(i=this.debounceTimers[n]={}),i.func=e,clearPendingTimeout();var o=i.promise;if(!o||!o.pending()){let e,t=\"pending\";(o=i.promise=new Promise((t=>{e=t}))).resolve=()=>{if(\"pending\"===t)if(t=\"fulfilled\",clearPendingTimeout(),this.debounceTimers[n]=null,\"function\"==typeof i.func){var r=i.func.call(this);r instanceof Promise||r&&\"function\"==typeof r.then?r.then((t=>e(t))):e(r)}else e()},o.cancel=()=>{t=\"rejected\",clearPendingTimeout(),this.debounceTimers[n]=null,o.resolve()},o.isPending=()=>\"pending\"===t}return i.timeout=setTimeout(o.resolve,null==t?250:t),o}clearDebounce(e){var t=this.debounceTimers[e];null!=t&&(t.timeout&&clearTimeout(t.timeout),t.promise&&t.promise.cancel())}clearAllDebounces(){let e=this.debounceTimers||{},t=Object.keys(e);for(let e=0,r=t.length;e<r;e++)this.clearDebounce(t[e])}getElementData(e){let t=E.get(e);return t||(t={},E.set(e,t)),t}}const w=Symbol.for(\"@jibs/node/contextID\");let j=1;class RootNode{static CONTEXT_ID=w;constructor(e,t,r){let n=e.createContext(r,this.onContextUpdate?this.onContextUpdate:void 0,this);Object.defineProperties(this,{id:{writable:!1,enumerable:!1,configurable:!1,value:j++},renderer:{writable:!0,enumerable:!1,configurable:!0,value:e},parent:{writable:!0,enumerable:!1,configurable:!0,value:t},context:{enumerable:!1,configurable:!0,get:()=>n,set:()=>{}},renderPromise:{writable:!0,enumerable:!1,configurable:!0,value:null},destroying:{writable:!0,enumerable:!1,configurable:!0,value:!1},renderFrame:{writable:!0,enumerable:!1,configurable:!0,value:0}})}destroy(){this.destroying=!0,this.context=null}isValidChild(e){return isValidChild(e)}isIterableChild(e){return isIterableChild(e)}propsDiffer(e,t,r){return propsDiffer(e,t,r)}childrenDiffer(e,t){return childrenDiffer(e,t)}async render(e,t){if(!this.destroying)return this.renderFrame++,this._render(e,t).then((e=>(this.renderPromise=null,e))).catch((e=>{throw this.renderPromise=null,e}))}}let v=0n;class RootElement{static TYPE_ELEMENT=1;static TYPE_TEXT=3;static TYPE_COMMENT=8;static TYPE_PORTAL=15;constructor(e,t,r,n){this.isJibsVirtualElement=!0,this.type=e,this.id=t,this.value=r,this.props=n||{}}}const _=Symbol.for(\"@jibsForceReflow\"),T={JIB_BARREN:l,JIB_PROXY:s,JIB:a,Jib,isJibish,constructJib,resolveChildren},P={UPDATE_EVENT:f,QUEUE_UPDATE_METHOD:b,FLUSH_UPDATE_METHOD:p,INIT_METHOD:d,SKIP_STATE_UPDATES:h,PENDING_STATE_UPDATE:m,LAST_RENDER_TIME:y,PREVIOUS_STATE:g},S={CONTEXT_ID:RootNode.CONTEXT_ID,FORCE_REFLOW:_,RootNode,Renderer:class Renderer extends EventEmitter{static RootNode=RootNode;constructor(){super(),Object.defineProperties(this,{context:{writable:!0,enumerable:!1,configurable:!0,value:this.createContext()},destroying:{writable:!0,enumerable:!1,configurable:!0,value:!1},renderFrame:{writable:!0,enumerable:!1,configurable:!0,value:0}})}createContext(e,t,r){let n=Object.create(null),i=e?e[w]:1n;return new Proxy(n,{get:(t,r)=>{if(r===w){let t=e?e[w]:1n;return t>i?t:i}return Object.prototype.hasOwnProperty.call(t,r)?t[r]:e?e[r]:void 0},set:(e,n,o)=>(n===w||e[n]===o||(i=++v,e[n]=o,\"function\"==typeof t&&t.call(r,r)),!0)})}},RootElement,CommentElement:class CommentElement extends RootElement{static TYPE=RootElement.TYPE_COMMENT;constructor(e,t,r){super(RootElement.TYPE_COMMENT,e,t,r)}},NativeElement:class NativeElement extends RootElement{static TYPE=RootElement.TYPE_ELEMENT;constructor(e,t,r){super(RootElement.TYPE_ELEMENT,e,t,r)}},PortalElement:class PortalElement extends RootElement{static TYPE=RootElement.TYPE_PORTAL;constructor(e,t,r){super(RootElement.TYPE_PORTAL,e,t,r)}},TextElement:class TextElement extends RootElement{static TYPE=RootElement.TYPE_TEXT;constructor(e,t,r){super(RootElement.TYPE_TEXT,e,t,r)}}}})();var n=r.$,i=r.wA,o=r.z8,l=r.El,s=r.pv,a=r.cQ,c=r.Be,u=r.d5;export{n as $,i as Component,o as Components,l as Jibs,s as Renderers,a as Utils,c as deadbeef,u as factory};\n//# sourceMappingURL=index.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export { DOMRenderer } from './dom-renderer.js';\nexport * from 'jibs';\n"],"names":[],"sourceRoot":""}